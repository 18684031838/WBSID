import os
import pandas as pd
import shutil
import urllib.parse
import re

# 设定 Exploit-DB 目录路径
exploit_db_path = r"D:\temp\exploitdb/"
csv_file_path = os.path.join(exploit_db_path, "files_exploits.csv")

output_dir = r"D:\Source\study\python\paper\src\data\Exploit-DB"
payload_output_file = "D:\Source\study\python\paper\src\data\Exploit-DB\sql_injection_http_payloads.csv"

# 确保目标目录存在
os.makedirs(output_dir, exist_ok=True)

# 读取 CSV 文件
df = pd.read_csv(csv_file_path)

# 过滤 "description" 包含 SQL Injection（不区分大小写）的漏洞
sqli_exploits = df[df["description"].str.contains("SQL Injection", case=False, na=False)]

# 复制匹配的 Exploit 文件到目标目录
for index, row in sqli_exploits.iterrows():
    file_path = os.path.join(exploit_db_path, row["file"])
    if os.path.exists(file_path):
        shutil.copy(file_path, output_dir)

print(f"已提取 {len(sqli_exploits)} 个 SQL 注入 Exploit 文件到 {output_dir}")

# ------------------ 解析 SQL 注入 Exploit 文件，生成 HTTP 载荷 ------------------

# SQL 注入测试 Payload
sql_payloads = [
    "' OR '1'='1",  # 经典的 OR 1=1 绕过验证
    "' UNION SELECT null, username, password FROM users --",  # UNION 查询
    "' AND SLEEP(5) --",  # 时间盲注
    "'; DROP TABLE users; --",  # 破坏性测试
    "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 --"  # 信息泄露
]

# 匹配 HTTP URL 中的 SQL 注入参数
http_sql_pattern = re.compile(r"(https?://[^\s]+)", re.IGNORECASE)

generated_payloads = []

# 遍历提取的 SQL 注入 Exploit 文件
for exploit_file in os.listdir(output_dir):
    exploit_path = os.path.join(output_dir, exploit_file)

    try:
        with open(exploit_path, "r", errors="ignore") as file:
            content = file.read()
            matches = http_sql_pattern.findall(content)  # 提取 URL

            for url in matches:
                for payload in sql_payloads:
                    injected_url = re.sub(r"=[^\s&]+", "=" + urllib.parse.quote(payload), url)  # 替换参数值
                    generated_payloads.append({"http_method": "GET", "url": injected_url, "payload": payload, "label": 1})

    except Exception as e:
        print(f"读取 {exploit_file} 失败: {e}")

# 保存 SQL 注入 HTTP 载荷到 CSV
df_payloads = pd.DataFrame(generated_payloads)
df_payloads.to_csv(payload_output_file, index=False)

print(f"已生成 {len(generated_payloads)} 条 SQL 注入 HTTP 载荷，并保存至 {payload_output_file}")
